{"meta":{"title":"BoiceBlog","subtitle":"大鹏一日同风起，扶摇直上九万里，假使风歇时下来，亦能颠阙沧溟水","description":"大鹏一日同风起，扶摇直上九万里，假使风歇时下来，亦能颠阙沧溟水","author":"Peng zhijian","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2022-07-13T08:04:07.000Z","updated":"2022-07-13T09:39:26.680Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"时间轴","date":"2022-07-11T15:21:55.000Z","updated":"2022-07-13T08:01:52.289Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-11T12:31:14.000Z","updated":"2022-07-13T08:02:00.275Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-07-13T07:31:29.000Z","updated":"2022-07-13T08:02:09.972Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"图片","date":"2022-07-13T07:35:27.000Z","updated":"2022-07-13T08:03:20.006Z","comments":true,"path":"pic/index.html","permalink":"http://example.com/pic/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 漫威 关于漫威的图片 OH MY GIRL 关于OH MY GIRL的图片"},{"title":"标签","date":"2022-07-11T13:25:38.000Z","updated":"2022-07-13T08:02:19.251Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"zookeeper","slug":"zookeeper","date":"2022-07-13T01:26:41.000Z","updated":"2022-07-13T11:23:32.316Z","comments":true,"path":"posts/3ad834c9/","link":"","permalink":"http://example.com/posts/3ad834c9/","excerpt":"","text":"ZooKeeper 命令操作ZooKeeper数据模型 Zookeeper是一个树形目录服务，他的数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构。 这里面的没一个节点都被称为:ZNODE,每个节点上都会保存自己的数据和结点信息. 节点可以有子节点，同时也允许少量(1MB)数据存储在该节点下。 节点分为四大类: PERSISTENT 持久化节点 EPHEMERAL 临时节点: -e PERSISTENT_SEQENTIAL 持久化顺序节点: -s EPHEMERAL _SEQENTIAL 临时顺序节点：-es ZooKeeper 服务端命令 启动 ./zkServer.sh start 停止./zkServer.sh stop 查看 ./zkServer.sh status 重启 ./zkServer.sh restart ZooKeeper 客户端命令 ./zkCli.sh -server localhost:2181 连接客户端 连接本机只需要./zCli.sh quit 退出命令 ls / /代表根节点 create / create之后跟目录 ,目录之后跟数据，数据也可以不写 有数据的可以使用get 加全路径获取数据 set命令可以给其设置数据 create 创建不能重复 delete 加全路径名删除 文件里面有子目录用deleteall进行删除 help 帮助命令，防止遗忘 ls - s /dubbo 查看dubbo的详细信息 CuratorCurator 常用API 创建连接 ~~~java @Test public void test1()&#123; // 1.第一种方式 /** * String connectString, 连接字符串.zk server地址和端口 * int sessionTimeoutMs, 会话超时时间，单位ms * int connectionTimeoutMs, 连接超时时间,单位ms * RetryPolicy retryPolicy 超时重传策略 */ //重试策略 ExponentialBackoffRetry retry = new ExponentialBackoffRetry(3000, 10); // CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(“192.168.116.128:2181”,// 60 * 1000, 15 * 1000, retry);// //开启连接// curatorFramework.start(); //第二种方式 CuratorFramework build = CuratorFrameworkFactory.builder().connectString(&quot;192.168.116.128:2181&quot;) .sessionTimeoutMs(60 * 1000).sessionTimeoutMs(15 * 1000).retryPolicy(retry). namespace(&quot;itheima&quot;).build(); build.start(); System.out.println(build); &#125; 12345678910- 创建结点 - 基本创建 - ~~~java // 基本创建 //创建结点没有指定数据，那么将当前客户端的ip当做数据进行存储 String s = client.create().forPath(&quot;/app1&quot;); System.out.println(s); 创建结点带数据 ```java String s = client.create().forPath(&quot;/app2&quot;, &quot;heh&quot;.getBytes(StandardCharsets.UTF_8)); 12345- 设置结点类型- ```java String s = client.create().withMode(CreateMode.PERSISTENT).forPath(&quot;/app3&quot;, &quot;heh3&quot;.getBytes(StandardCharsets.UTF_8)); 创建多级结点 /app1/p1 ```javaString s = client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(“/node/app1”, “node”.getBytes(StandardCharsets.UTF_8)); 123456789101112131415161718192021222324252627- 查询结点： - 查询数据:getData() - 查询子节点: ls getChildren() - 查询结点状态信息:ls -s - - ```java @Test public void testFind() throws Exception &#123; // 1.第一种方式 //查询数据 // client.get // byte[] bytes = client.getData().forPath(&quot;/app1&quot;); // System.out.println(new String(bytes)); //查询子节点 // List&lt;String&gt; strings = client.getChildren().forPath(&quot;/&quot;); // System.out.println(strings); // 查询结点的状态信息 Stat stat = new Stat(); client.getData().storingStatIn(stat).forPath(&quot;/app1&quot;); System.out.println(stat); &#125; 修改结点: ```@Testpublic void testSet() throws Exception { Stat stat = new Stat(); client.getData().storingStatIn(stat).forPath(&quot;/app1&quot;); // withVersion根据版本修改，为-1则标识为忽略版本号,version是通过查询出来的，目的让其他客户端或者线程不干扰我 stat = client.setData() // 版本号 -1 标识忽略版本号 .withVersion(stat.getVersion()) .forPath(&quot;/app1&quot;, &quot;kiss&quot;.getBytes()); System.out.println(stat); } 12345678910111213141516171819202122232425262728293031- 删除结点:- - ```java @Test public void testDelete() throws Exception &#123; // Stat stat = new Stat(); // client.getData().storingStatIn(stat).forPath(&quot;/app1&quot;); // 删除单个结点 // withVersion根据版本修改，为-1则标识为忽略版本号,version是通过查询出来的，目的让其他客户端或者线程不干扰我 // client.delete().withVersion(stat.getVersion()) // .forPath(&quot;/app1&quot;); // System.out.println(stat); // 删除带有子节点的节点 // client.delete().deletingChildrenIfNeeded().forPath(&quot;/node&quot;); //必须成功的删除 // client.delete().guaranteed().forPath(&quot;/app2&quot;); //回调 client.delete().guaranteed().inBackground(new BackgroundCallback() &#123; @Override public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception &#123; System.out.println(&quot;我被删除了&quot;); System.out.println(curatorFramework + &quot; &quot; + curatorEvent); &#125; &#125;).forPath(&quot;/app3&quot;); &#125; Watch事件监听 Zookeeper允许客户在指定节点上注册一个Watch，并且在一些特定时间出发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性. NodeCache @Test public void testNodeCache() throws Exception &#123; // 1. 创建NodeCache对象 NodeCache nodeCache = new NodeCache(client,&quot;/app1&quot;, false); // 2. 注册监听 nodeCache.getListenable().addListener(new NodeCacheListener() &#123; @Override public void nodeChanged() throws Exception &#123; System.out.println(&quot;节点变化了&quot;); //获取修改节点后的数据 byte[] data = nodeCache.getCurrentData().getData(); System.out.println(new String(data)); &#125; &#125;); //3. 开启监听,如果设置为True则开启监听时加载缓冲数据 nodeCache.start(true); while (true)&#123; &#125; &#125; 其他的类只是功能不一样，使用方法雷同","categories":[{"name":"分布式","slug":"分布式","permalink":"http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"注册中心","slug":"注册中心","permalink":"http://example.com/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"},{"name":"配置管理","slug":"配置管理","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/"},{"name":"分布式系统","slug":"分布式系统","permalink":"http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}]},{"title":"Dubbo","slug":"Dubbo","date":"2022-07-11T13:19:48.000Z","updated":"2022-07-13T11:34:41.442Z","comments":true,"path":"posts/f6253398/","link":"","permalink":"http://example.com/posts/f6253398/","excerpt":"","text":"Dubbo简介Dubbo 是一款高性能、轻量级的开源Java RPC框架，提供面向接口代理的高性能RPC调用、智能负载均衡、服务自动注册和发现、运行期流量调度、可视化服务治理和运维等功能。 大型互联网项目架构目标衡量网站的性能指标: 吞吐量 单位时间内能处理的请求数 QPS: 每秒查询数 TPS: 每秒 响应时间 执行一个请求从开始到最后收到响应花费的所有时间 高性能 高可用 并发数：同时能处理的请求数量 并发连接数 请求数QPS 并发用户数 可伸缩：通过硬件增加/减少，提高/降低处理能力。 高可扩展:系统间耦合度低，方便通过新增/移除方式，增加/减少新的功能/模块。 互联网项目特点： 用户多 流量大，并发高 海量数据 易受攻击 功能繁琐 变更快 集群和分布式 集群 多个部分做同样的事情 一个业务模块，部署在多台服务器上 分布式 多个部分做不同的事情 一个大的业务系统，拆分成多个小的模块，部署在多台机器上 架构演进单体架构优点： 简单：开发部署都很方便，小型项目首选 缺点： 项目启动慢 可靠性差 可伸缩性差 扩展性和可维护性差 性能低 Dubbo高级特性-负载均衡策略： Random按权重随机，默认值。按照权重设计随机概率。","categories":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://example.com/categories/Dubbo/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"Dubbo","slug":"Dubbo","permalink":"http://example.com/tags/Dubbo/"}]},{"title":"背包问题全解","slug":"Bag","date":"2022-07-11T09:48:26.000Z","updated":"2022-07-13T11:37:27.213Z","comments":true,"path":"posts/236f2ea1/","link":"","permalink":"http://example.com/posts/236f2ea1/","excerpt":"","text":"背包问题01背包问题有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。 第 ii 件物品的体积是 vivi，价值是 wiwi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。 输出格式输出一个整数，表示最大价值。 数据范围0&lt;N,V≤10000&lt;N,V≤10000&lt;vi,wi≤10000&lt;vi,wi≤1000 输入样例123454 51 22 43 44 5 输出样例：18 解题思路:123456789101112状态表示 f[i][j] 集合 表示取前i件物品，体积为j的时候能取到的最大价值 属性 max集合划分使用最后一个变化的状态也就是f[i-1]表示取前i-1件物品，这个时候如果j&gt;=v[i] 两种情况：取第i件物品，不取第i件物品，取最大值 即f[i][j] = max(f[i-1][j], f[i - 1][j - v[i]] + w[i]) 需要的是上一个状态的下的方程。 二维状态下 时间复杂度和空间复杂度均为O(NV)优化成一维： 因为需要上一个状态的数值，那么可以让体积j从大到小枚举，保证每一次使用的体积是上一次剩下的体积 一维状态下的时间复杂度没有变，但是空间复杂度被优化到O(V) 不明白如下图: code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.*;/** * Created by IntelliJ IDEA. * User: pzj * Date: 2022/7/10 * Time: 9:36 */public class Main &#123; private static final int N = 1010;// private static final int [][] f = new int[N][N]; /** * f[i][j]表示在取前i件物品，体积为j的时候能取到的最大价值 * * @param args * @throws IOException */// public static void main(String[] args) throws IOException &#123;// BufferedReader br = new BufferedReader(new InputStreamReader(System.in));// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));// String[] s = br.readLine().split(&quot; &quot;);// int n = Integer.parseInt(s[0]);// int m = Integer.parseInt(s[1]);// // 每次输入一堆v，w值，因为对于dp来说每一次都是用一组v，w值取更新，所以可以不用数组来接收// for (int i = 1; i &lt;= n ; i++) &#123;// String[] s1 = br.readLine().split(&quot; &quot;);// int v = Integer.parseInt(s1[0]);// int w = Integer.parseInt(s1[1]);// for(int j = 0 ; j &lt;= m;j++)&#123;// f[i][j] = f[i-1][j];// if(j &gt;= v)&#123;// f[i][j] = Math.max(f[i][j], f[i-1][j-v] + w);// &#125;// &#125;// &#125;// int res = 0;// for(int i = 0 ; i &lt;= m;i++) res = Math.max(res, f[n][i]);// System.out.println(res);// br.close();// bw.close();//// &#125; private static final int [] f = new int[N]; /** * f[i]表示体积为i时物品价值的最大值 * 为了保证此时的f[i]使用的状态是上一次的状态，可以让体积从大到小进行计算，保证每一次使用的体积是上一次剩下的状态 * 此时f[m]必定为最大值 * 证明: * 如果f[k] = max_w,两种情况: * 从f[0]转移 ==&gt;f[v[0]] + w[0] == &gt; ...==&gt; f[k] * 不从f[0]转移，其实本质上是一样的f那么从f[m - k]转移，因为所有的f值初始化为0， * 那么可以通过同样的转移路径得到f[m] = f[m - k] == &gt; ..... ==&gt; f[m]和f[k]的值是一样的，所以f[m]一定是最大值 * 如果吧f[0]初始化为0,其他值初始化为负无穷，可以保证此时路径必定只能从f[0]进行转移,此时需要循环判断哪里是最大值 * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] s = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(s[0]); int m = Integer.parseInt(s[1]); // 每次输入一堆v，w值，因为对于dp来说每一次都是用一组v，w值取更新，所以可以不用数组来接收 for (int i = 1; i &lt;= n ; i++) &#123; String[] s1 = br.readLine().split(&quot; &quot;); int v = Integer.parseInt(s1[0]); int w = Integer.parseInt(s1[1]); for(int j = m ; j &gt;= v;j--)&#123;// System.out.println(j - v); f[j] = Math.max(f[j], f[j-v] + w); &#125; &#125; System.out.println(f[m]); br.close(); bw.close(); &#125;&#125; 完全背包问题有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。 第 ii 种物品的体积是 vivi，价值是 wiwi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。 输出格式输出一个整数，表示最大价值。 数据范围0&lt;N,V≤10000&lt;N,V≤10000&lt;vi,wi≤10000&lt;vi,wi≤1000 输入样例123454 51 22 43 44 5 输出样例：110 解题思路:1234567891011121314因为每一种物品都可以无限使用，那么完全背包问题就是在01背包问题的情况下添加一下物品的限制相当于有无数件物品，只需要判断每一次 k * v[i] &lt;= j的时候，每一次都判断f[j]以及f[j - k * v] + w * k 的最大值即可。状态表示 f[i][j] 集合 表示取前i件物品，体积为j的时候能取到的最大价值 属性 max集合划分使用最后一个变化的状态也就是f[i-1]表示取前i-1件物品，这个时候如果j&gt;=v[i] 两种情况：取第i件物品，不取第i件物品，取最大值 即f[i][j] = max(f[i-1][j], f[i - 1][j - v[i]] + w[i]) 需要的是上一个状态的下的方程。 二维状态下 时间复杂度和空间复杂度均为O(NV)优化成一维： 因为需要上一个状态的数值，那么可以让体积j从大到小枚举，保证每一次使用的体积是上一次剩下的体积 一维状态下的时间复杂度没有变，但是空间复杂度被优化到O(V) code123456789101112131415161718192021222324252627282930313233343536import java.io.*;/** * Created by IntelliJ IDEA. * User: pzj * Date: 2022/7/10 * Time: 10:24 */public class Main &#123; private static final int N = 1010; private static final int [] f = new int[N]; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] s = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(s[0]); int m = Integer.parseInt(s[1]); // 每次输入一堆v，w值，因为对于dp来说每一次都是用一组v，w值取更新，所以可以不用数组来接收 for (int i = 1; i &lt;= n ; i++) &#123; String[] s1 = br.readLine().split(&quot; &quot;); int v = Integer.parseInt(s1[0]); int w = Integer.parseInt(s1[1]); for(int j = m ; j &gt;= v;j--)&#123;// System.out.println(j - v); for(int k = 1; k * v&lt;= j;k++) f[j] = Math.max(f[j], f[j-k * v] + k * w); &#125; &#125; System.out.println(f[m]); br.close(); bw.close(); &#125;&#125; 多重背包问题1有 NN 种物品和一个容量是 VV 的背包。 第 ii 种物品最多有 sisi 件，每件体积是 vivi，价值是 wiwi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 NN 行，每行三个整数 vi,wi,sivi,wi,si，用空格隔开，分别表示第 ii 种物品的体积、价值和数量。 输出格式输出一个整数，表示最大价值。 数据范围0&lt;N,V≤1000&lt;N,V≤1000&lt;vi,wi,si≤1000&lt;vi,wi,si≤100 输入样例123454 51 2 32 4 13 4 34 5 2 输出样例：110 解题思路1234567891011121314因为每一种物品都可以无限使用，那么完全背包问题就是在01背包问题的情况下添加一下物品的限制相当于有无数件物品，只需要判断每一次 k * v[i] &lt;= j &amp;&amp; k &lt;= s ，s是物品限制的时候，每一次都判断f[j]以及f[j - k * v] + w * k 的最大值即可。状态表示 f[i][j] 集合 表示取前i件物品，体积为j的时候能取到的最大价值 属性 max集合划分使用最后一个变化的状态也就是f[i-1]表示取前i-1件物品，这个时候如果j&gt;=v[i] 两种情况：取第i件物品，不取第i件物品，取最大值 即f[i][j] = max(f[i-1][j], f[i - 1][j - v[i]] + w[i]) 需要的是上一个状态的下的方程。 二维状态下 时间复杂度和空间复杂度均为O(NV)优化成一维： 因为需要上一个状态的数值，那么可以让体积j从大到小枚举，保证每一次使用的体积是上一次剩下的体积 一维状态下的时间复杂度没有变，但是空间复杂度被优化到O(V) code12345678910111213141516171819202122232425262728293031323334353637import java.io.*;/** * Created by IntelliJ IDEA. * User: pzj * Date: 2022/7/10 * Time: 10:24 */public class Main &#123; private static final int N = 1010; private static final int [] f = new int[N]; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] s = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(s[0]); int m = Integer.parseInt(s[1]); // 每次输入一堆v，w值，因为对于dp来说每一次都是用一组v，w值取更新，所以可以不用数组来接收 for (int i = 1; i &lt;= n ; i++) &#123; String[] s1 = br.readLine().split(&quot; &quot;); int v = Integer.parseInt(s1[0]); int w = Integer.parseInt(s1[1]); int s2 = Integer.parseInt(s1[2]); for(int j = m ; j &gt;= v;j--)&#123;// System.out.println(j - v); for(int k = 1; k * v&lt;= j &amp;&amp; k &lt;= s2;k++) f[j] = Math.max(f[j], f[j-k * v] + k * w); &#125; &#125; System.out.println(f[m]); br.close(); bw.close(); &#125;&#125; 时间复杂度O(N^3)，空间复杂度o(V) 二进制优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.io.*;import java.util.ArrayList;import java.util.List;/** * Created by IntelliJ IDEA. * User: pzj * Date: 2022/7/10 * Time: 10:24 */public class Main &#123; private static final int N = 2010; private static final int [] f = new int[N];// public static void main(String[] args) throws IOException &#123;// BufferedReader br = new BufferedReader(new InputStreamReader(System.in));// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));// String[] s = br.readLine().split(&quot; &quot;);// int n = Integer.parseInt(s[0]);// int m = Integer.parseInt(s[1]);// // 每次输入一堆v，w值，因为对于dp来说每一次都是用一组v，w值取更新，所以可以不用数组来接收// for (int i = 1; i &lt;= n ; i++) &#123;// String[] s1 = br.readLine().split(&quot; &quot;);// int v = Integer.parseInt(s1[0]);// int w = Integer.parseInt(s1[1]);// for(int j = m ; j &gt;= v;j--)&#123;//// System.out.println(j - v);// for(int k = 1; k * v&lt;= j;k++)// f[j] = Math.max(f[j], f[j-k * v] + k * w);//// &#125;// &#125;// System.out.println(f[m]);// br.close();// bw.close();//// &#125; /** * 二进制优化算法 * 转换为0,1背包问题，分成s份放入物品堆当中,那么7 可以被拆成 1 2 4三种数据来表示0-7中的所有数 * @param args * @throws IOException */ static List&lt;Goods&gt; list = new ArrayList&lt;Goods&gt;(); public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] s = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(s[0]); int m = Integer.parseInt(s[1]); // 每次输入一堆v，w值，因为对于dp来说每一次都是用一组v，w值取更新，所以可以不用数组来接收 for (int i = 1; i &lt;= n ; i++) &#123; String[] s1 = br.readLine().split(&quot; &quot;); int v = Integer.parseInt(s1[0]); int w = Integer.parseInt(s1[1]); int s2 = Integer.parseInt(s1[2]); for (int k = 1; k &lt;= s2 ; k *=2) &#123; s2 -= k; list.add(new Goods(v * k, w * k)); &#125; if(s2 &gt; 0)&#123; list.add(new Goods(s2 * v, s2 * w)); &#125; &#125; for (Goods good :list) &#123; for (int j = m; j &gt;= good.getV(); j--) &#123; f[j] = Math.max(f[j],f[j-good.getV()] + good.getW()); &#125; &#125; System.out.println(f[m]); br.close(); bw.close(); &#125;&#125;class Goods&#123; private int v; private int w; public Goods() &#123; &#125; public Goods(int v,int w) &#123; this.v = v; this.w = w; &#125; public int getV() &#123; return v; &#125; public void setV(int v) &#123; this.v = v; &#125; public int getW() &#123; return w; &#125; public void setW(int w) &#123; this.w = w; &#125;&#125; 时间复杂度O(N^2logN)，空间复杂度o(V) 单调队列优化分组背包问题有 NN 组物品和一个容量是 VV 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 vijvij，价值是 wijwij，其中 ii 是组号，jj 是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式第一行有两个整数 N，VN，V，用空格隔开，分别表示物品组数和背包容量。 接下来有 NN 组数据： 每组数据第一行有一个整数 SiSi，表示第 ii 个物品组的物品数量； 每组数据接下来有 SiSi 行，每行有两个整数 vij,wijvij,wij，用空格隔开，分别表示第 ii 个物品组的第 jj 个物品的体积和价值； 输出格式输出一个整数，表示最大价值。 数据范围0&lt;N,V≤1000&lt;N,V≤1000&lt;Si≤1000&lt;Si≤1000&lt;vij,wij≤1000&lt;vij,wij≤100 输入样例123456783 521 22 413 414 5 输出样例：18 解题思路12集合划分的时候从每一组的每一个物品去取最大值，保证集合划分不重不漏，刚好能覆盖一组的所有物品，即为01背包中的一个物品变成一组物品第i组物品前一个状态是第i-1组物品 不明白如下图: code1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.*;import java.util.Scanner;/** * Created by IntelliJ IDEA. * User: pzj * Date: 2022/7/10 * Time: 14:48 * 分组背包 */public class Main &#123; private static final int N = 1010; private static final int [] f = new int [N]; private static final int [] v = new int [N]; private static final int [] w = new int [N]; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); Scanner scanner = new Scanner(System.in); String[] s = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(s[0]); int m = Integer.parseInt(s[1]); // 每次输入一堆v，w值，因为对于dp来说每一次都是用一组v，w值取更新，所以可以不用数组来接收 for (int i = 1; i &lt;= n ; i++) &#123; String s1 = br.readLine(); int x = Integer.parseInt(s1); for (int j = 0; j &lt; x ; j++) &#123; String[] s2 = br.readLine().split(&quot; &quot;); v[j] = Integer.parseInt(s2[0]); w[j] = Integer.parseInt(s2[1]); &#125; for (int j = m; j &gt;= 0; j--) &#123; for (int k = 0; k &lt; x; k++) &#123; if(j &gt;= v[k]) f[j] =Math.max(f[j], f[j - v[k]] + w[k]); &#125; &#125; &#125; System.out.println(f[m]); br.close(); bw.close(); &#125;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"背包问题","slug":"背包问题","permalink":"http://example.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-11T03:04:10.874Z","updated":"2022-07-11T09:22:02.817Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"http://example.com/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"分布式","slug":"分布式","permalink":"http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"Dubbo","slug":"Dubbo","permalink":"http://example.com/categories/Dubbo/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"注册中心","slug":"注册中心","permalink":"http://example.com/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"},{"name":"配置管理","slug":"配置管理","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/"},{"name":"分布式系统","slug":"分布式系统","permalink":"http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"Dubbo","slug":"Dubbo","permalink":"http://example.com/tags/Dubbo/"},{"name":"背包问题","slug":"背包问题","permalink":"http://example.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}